<?php

function maxPrimeNumberDivider($number) {
    //простой пример число 30. Положим, что мы его можем представить как 30 = a * b:
    //30 / 1 = 30;
    //30 / 2 = 15;
    //30 / 3 = 10;
    //30 / 5 = 6;
    //ниже варианты рассматривать смысла нет, ибо мы просто заходим на второй круг, что нам уже известно из 4 операций выше
    //мы просто тупо меняем местами a и b в этом случае, что нам неинтересно. Но для ясности все-таки убедимся, что это правда и так бывает
    //30 / 6 = 5;
    //30 / 10 = 3;
    //30 / 15 = 2;
    //30 / 30 = 1;
    //а следовательно мы не должны искать делители больше чем квадратный корень искомого числа (ну или лучше сказать квадратного корня округленного
    //в большую сторону до целого числа, ибо мы же делители целые числа ищем).

    //на 1 делить не будем, ибо какой нам интерес представлять число 30 как 30 * 1 * 1 * 1 и т.д.
    //делим 30 / 2 = 15, ок, получили целочисленный остаток от деления 15. Если это простое число, то мы никогда не сможем найти для него делитель так, чтобы
    //поделить его без остатка.
    //а если оно составное то сможем найти целочисленный делитель отличный от 1 и 15
    //и тогда у нас будет 30 = 2 * a * b, где a * b = 15. ок пробуем.
    //15 / 3 = 5, ок, получили целочисленный остаток от деления. Таким образом мы уже имеем 30 = 2 * 3 * 5.
    //теперь пробуем найти целочисленный остаток деления числа 5, чтобы его также можно было представить как произведение 5 = a * b, ок пробуем.
    //5 / 4 не катит
    //5 / 5, а тут мы уже делим на число равное себе а это уже нам не нужно, ибо какой смысл в 30 = 2 * 3 * 5 * 1 * 1 * 1 * 1 (где единицу можно до бесконечности писать).
    //ну вот и все, наше искомое число и есть 5 (самое большое, ибо числа множители всегда у нас встанут в порядке возрастания), оно простое,
    //ибо мы не можем его разложить на делители отличные от 1 и 5.

    $divider = 2;
    $dividerToReturn = null; // последний найденный множитель числа. может так случится, что у нас число исходное простое и не найдем мы никаких делителей.
    $maxValueOfDivider = $number;
    //как уже говорилось нет смысла искать среди чисел больших квадратного корня
    //а так же нет смысла искать, если в нашем делении мы дошли до 1
    while ($divider <= ceil(pow($number, 0.5)) && $maxValueOfDivider !== 1)
    {
        if ($maxValueOfDivider % $divider === 0) {
            //нашли очередной (а может и первый) делитель. Здесь мы не отвечаем сражу же на вопрос простой он или нет.
            //но он будет простым, если мы никогда больше здесь не окажемся.
            //ну и выставляем значение, что нашли хоть один раз, ибо мы вообще можем сюда никогда не зайти, если наше исходного число простое.
            $maxValueOfDivider = $maxValueOfDivider / $divider;
            $dividerToReturn = $divider;
        } else {
            //не делится целочисленно, ну значит будем искать дальше
            $divider ++;
        }
    }
    if (!is_null($dividerToReturn)) {
        return $dividerToReturn;
    } else {
        return 'There is no dividers for ' . $number; //нельзя разложить число на делители, ибо само по себе исходное число оказалось простым.
    }

}

$start = microtime(true);
echo maxPrimeNumberDivider(600851475143).PHP_EOL; //6857
echo maxPrimeNumberDivider(41).PHP_EOL;
echo microtime(true) - $start;